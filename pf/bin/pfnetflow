#!/usr/bin/perl

=head1 NAME

pfnetflow - listen to netflow/IPFIX traffic and create PF violations

=head1 SYNOPSIS

pfnetflow -i <interface> -p <port> [options]

 Options:
   -d     Daemonize
   -h     Help

=cut

use strict;
use warnings;
use Getopt::Std;
use File::Basename qw(basename);
use POSIX qw(:signal_h);
use Log::Log4perl;
use Pod::Usage;
use Net::Flow qw(decode) ;
use IO::Socket::INET;

use constant INSTALL_DIR => '/usr/local/pf';

use lib INSTALL_DIR . "/lib";
use pf::db;
use pf::config;
use pf::util;

my $binary_name = basename($0);

Log::Log4perl->init( INSTALL_DIR . "/conf/log.conf" );
my $logger = Log::Log4perl->get_logger($binary_name);
Log::Log4perl::MDC->put('proc', $binary_name);
Log::Log4perl::MDC->put('tid',  0);

POSIX::sigaction(
    &POSIX::SIGHUP,
    POSIX::SigAction->new('normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER)
) or $logger->logdie("$binary_name: could not set SIGHUP handler: $!");

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new('normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER)
) or $logger->logdie("$binary_name: could not set SIGTERM handler: $!");

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new('normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER)
) or $logger->logdie("$binary_name: could not set SIGINT handler: $!");


my @ORIG_ARGV = @ARGV;
my %args;
getopts( 'dhvi:p:', \%args );

my $daemonize = $args{d};
my $verbose = $args{v};
my $interface = $args{i};
my $port = $args{p};

pod2usage( -verbose => 1 ) if ( $args{h} || !($args{p} && $args{i}) );

daemonize() if ($daemonize);

$logger->info("initialized");

my $packet = undef;
my $TemplateArrayRef = undef;
my $templateReceivedFlag = 0;
#TODO: honor the -i parameter from CLI, wait do we really need that?
#I think its easier to listen to everything (and filter with firewall)
#or maybe with an IP param (that we can grab from pf.conf)
my $sock = IO::Socket::INET->new(LocalPort => $port, Proto => 'udp')
  or $logger->logdie("Can't bind to UDP port $port. Netflow analysis stopped. OS error: $!");

$logger->info("Listening on UDP $port. Netflow/IPFIX analysis started.");

my $info_string = "Size\t#pkts\tsrcip\t\tsrcport\tdstip\t\tdstport\tsrcmac\t\t\tdstmac\t\t\tnexthop";

# main loop
while ($sock->recv($packet,1548)) {

    $logger->debug("received flow from: ". $sock->peerhost());

    # forces re-init of variables
    my ($HeaderHashRef,$FlowArrayRef,$ErrorsArrayRef) = ();

    ($HeaderHashRef, $TemplateArrayRef, $FlowArrayRef, $ErrorsArrayRef)
         = Net::Flow::decode(\$packet, $TemplateArrayRef);

    # TODO: ERROR-HANDLING:
    # grep{ print "$_\n" }@{$ErrorsArrayRef} if( @{$ErrorsArrayRef} ) ;

    if (!$templateReceivedFlag && @{$TemplateArrayRef}) {
        $logger->info("Received the template. Flows are now interpreted.");
        $templateReceivedFlag = 1;
    }

    if (!@{$TemplateArrayRef}) {
        $logger->debug("No template received yet. Can't parse the netflow/IPFIX until a template has been received");
    } 

    if (@{$FlowArrayRef}) {
        $logger->trace($info_string);
    }
    foreach my $FlowRef ( @{$FlowArrayRef} ){

        # date is epoch: int($FlowRef->{22}/1000) + $HeaderHashRef->{"UnixSecs"} #warning: int is not rounding precisely
        my $start_time = hex(unpack("H*", $FlowRef->{22}));
        my $end_time = hex(unpack("H*", $FlowRef->{21}));
        my $numberOfPackets = hex(unpack("H*", $FlowRef->{10}));
     
        my $nexthop = join('.', unpack('CCCC', $FlowRef->{15}));
     
        if($numberOfPackets ne "0"){
            my $data;
            $start_time += $HeaderHashRef->{"UnixSecs"} * 1000;
            $end_time += $HeaderHashRef->{"UnixSecs"} * 1000;
       
            #$data = "FLOW $start_time $end_time ";
            $data = hex(unpack("H*",$FlowRef->{1})) . "\t";                                # Size of Flow
            $data = $data . $numberOfPackets . "\t";                                       # Number of packets
            $data = $data . join('.', unpack('CCCC',$FlowRef->{8})) . "\t";                # Source Address
            $data = $data . hex(unpack("H*",$FlowRef->{7})) . "\t";                        # Source Port
            $data = $data . join('.', unpack('CCCC',$FlowRef->{12})) . "\t";               # Destination Address
            $data = $data . hex(unpack("H*",$FlowRef->{11})) . "\t";                       # Destination Port
            $data = $data . join(':', unpack('H2 H2 H2 H2 H2 H2', $FlowRef->{56})) . "\t"; # Source MAC Address
            $data = $data . join(':', unpack('H2 H2 H2 H2 H2 H2', $FlowRef->{57})) . "\t"; # Destination MAC Address
            $data = $data . join('.', unpack('CCCC',$FlowRef->{15}));                      # Next Hop Address
       
            $logger->trace($data);
        }
    }
}


END {
    deletepid();

    # TODO free resources
}

exit(0);

sub daemonize {
    chdir '/' or $logger->logdie("Can't chdir to /: $!");
    open STDIN, '<', '/dev/null'
        or $logger->logdie("Can't read /dev/null: $!");
    my $log_file = "$install_dir/logs/$binary_name";
    open STDOUT, '>>', $log_file
        or $logger->logdie("Can't write to $log_file: $!");

    defined( my $pid = fork )
        or $logger->logdie("$binary_name: could not fork: $!");
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        $logger->warn("could not start a new session: $!");
    }
    open STDERR, '>&STDOUT' or $logger->logdie("Can't dup stdout: $!");
    createpid();
}

sub normal_sighandler {
    deletepid();
    $logger->logdie( "caught SIG" . $_[0] . " - terminating" );
}


=head1 AUTHOR

Olivier Bilodeau <obilodeau@inverse.ca>

=head1 COPYRIGHT

Copyright (C) 2009,2010 Inverse inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

