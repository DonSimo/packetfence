#!/usr/bin/perl

=head1 NAME

pfnetflow - listen to netflow/IPFIX traffic and create PF violations

=head1 SYNOPSIS

pfnetflow -i <interface> -p <port> [options]

 Options:
   -d     Daemonize
   -h     Help

=cut

use strict;
use warnings;
use Getopt::Std;
use File::Basename qw(basename);
use POSIX qw(:signal_h);
use Log::Log4perl;
use Pod::Usage;
use Net::Flow qw(decode) ;
use IO::Socket::INET;

use constant INSTALL_DIR => '/usr/local/pf';

#FIXME temporary
#use lib INSTALL_DIR . "lib";
use lib "lib";

use pf::flow::custom;
use pf::config;
use pf::util;

my $binary_name = basename($0);

Log::Log4perl->init( INSTALL_DIR . "/conf/log.conf" );
my $logger = Log::Log4perl->get_logger($binary_name);
Log::Log4perl::MDC->put('proc', $binary_name);
Log::Log4perl::MDC->put('tid',  0);


# initialization
POSIX::sigaction(
    &POSIX::SIGHUP,
    POSIX::SigAction->new('normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER)
) or $logger->logdie("$binary_name: could not set SIGHUP handler: $!");

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new('normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER)
) or $logger->logdie("$binary_name: could not set SIGTERM handler: $!");

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new('normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER)
) or $logger->logdie("$binary_name: could not set SIGINT handler: $!");


my @ORIG_ARGV = @ARGV;
my %args;
getopts( 'dhvi:p:', \%args );

my $daemonize = $args{d};
my $verbose = $args{v};
my $interface = $args{i};
my $port = $args{p};

pod2usage( -verbose => 1 ) if ( $args{h} || !($args{p} && $args{i}) );

daemonize() if ($daemonize);

$logger->info("initialized");

# main loop
listen_flow($port);

=head1 SUBROUTINES

=over

=item listen_flow 

open the socket and listens to the flow

=cut
sub listen_flow {
    my ($port) = @_;
    my $logger = Log::Log4perl->get_logger("$binary_name");

    my $packet = undef;

    #TODO: honor the -i parameter from CLI, wait do we really need that?
    #I think its easier to listen to everything (and filter with firewall)
    #or maybe with an IP param (that we can grab from pf.conf)
    my $sock = IO::Socket::INET->new(LocalPort => $port, Proto => 'udp')
        or $logger->logdie("Can't bind to UDP port $port. Netflow analysis stopped. OS error: $!");
    
    $logger->info("Listening on UDP $port. Netflow/IPFIX analysis started.");
    
    my $flow = new pf::flow::custom();
    while ($sock->recv($packet,1548)) {

        $logger->debug("received flow from: ". $sock->peerhost());
        $flow->processFlowPacket(\$packet);
    }
}

END {
    deletepid();

    # TODO free resources
}

exit(0);

sub daemonize {
    chdir '/' or $logger->logdie("Can't chdir to /: $!");
    open STDIN, '<', '/dev/null'
        or $logger->logdie("Can't read /dev/null: $!");
    my $log_file = "$install_dir/logs/$binary_name";
    open STDOUT, '>>', $log_file
        or $logger->logdie("Can't write to $log_file: $!");

    defined( my $pid = fork )
        or $logger->logdie("$binary_name: could not fork: $!");
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        $logger->warn("could not start a new session: $!");
    }
    open STDERR, '>&STDOUT' or $logger->logdie("Can't dup stdout: $!");
    createpid();
}

sub normal_sighandler {
    deletepid();
    $logger->logdie( "caught SIG" . $_[0] . " - terminating" );
}

=back

=head1 AUTHOR

Olivier Bilodeau <obilodeau@inverse.ca>

=head1 COPYRIGHT

Copyright (C) 2009,2010 Inverse inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

