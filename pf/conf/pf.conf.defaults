[general]
#
# general.domain
#
# Domain name of PacketFence system.
domain=example.com
#
# general.hostname
#
# Hostname of PacketFence system.  This is concatenated with the domain in Apache rewriting rules and therefore must be resolvable by clients.
hostname=abc
#
# general.logo
#
# Logo displayed on web pages.
logo=/common/packetfence.png
#
# general.dnsservers
#
# Comma-delimited list of DNS servers.  Passthroughs are created to allow queries to these servers from even "trapped" nodes.
dnsservers=127.0.0.1
#
# general.dhcpservers
#
# Comma-delimited list of DHCP servers.  Passthroughs are created to allow DHCP transactions from even "trapped" nodes.
dhcpservers=127.0.0.1
#
# general.caching
#
# Enable caching of isinternal values as well as other fun stuff.  Leave this enabled or suffer the performance consequences.
caching=enabled
#
# general.locale
#
# Locale used for message translation
# more than 1 can be specified
locale=en_US
#
# general.maintenance_interval
#
# Interval at which Packetfence runs its maintenance tasks.
maintenance_interval=60s

[arp]
#
# arp.dhcp_timeout
#
# Used in detection of systems with static IP addresses.  Looks for broadcast DHCPDISCOVERs and flags a node as rogue if it 
# fails to see one before timer is exceeded.  This value should be greater than 50% of your DHCP lease time.
# 
dhcp_timeout=8h
#
# arp.cleanshutdown
#
# If enabled, ARPs are sent to all trapped systems to re-point them to the correct gateway device at shutdown.
cleanshutdown=enabled
#
# arp.interval
#
# Interval at which poisoned ARPs ("traps") are sent to infected/unregistered systems.
interval=60s
#
# arp.strobe
#
# If enabled, sends ARP request to all IP addresses within range immediately after startup.  This allows for the internal MAC 
# to IP mappings to be populated quickly.
strobe=enabled
#
# arp.gw_timeout
#
# Used in detection of systems with statically-defined gateway ARP entries.  If a system has not ARPed for the gateway 
# within this interval, it is removed from the IP->MAC mappings and should be flagged as rogue by the next probe.
gw_timeout=1d
#
# arp.timeout
#
# Length of time of inactivity after which an unresponsive system is aged out.  Hello ARPs are sent at timeout/2 
# and timeout-interval to avoid prematurely timing out a system.
timeout=8h
#
# arp.heartbeat
#
# To eliminate the negative effects of switch flooding of poisoned ARPs on some (cough...cough...Netgear MR814v2) routers, we 
# must first send a valid ARP to establish that the system is on-line.  The heartbeat is the length of time between the initial
# "hello" and a poisoned "goodbye".
heartbeat=30s
#
# arp.stuffing
#
# If enabled, forces PF system to "stuff" router ARP cache with a bogus MAC for systems that are not responding.  This 
# option effectively increases the "stickiness" of traps by suppressing broadcast ARP traffic from the gateway.  It is also 
# somewhat dangerous in that it relies on systems to issue a GARP (gratuitous ARP) at boot to reclaim previously stuffed 
# addresses.
stuffing=disabled

[network]
#
# network.mode
#
# Defines the mode in which PacketFence will operate.
# 
# When deployed in arp mode, PacketFence uses ARP manipulation inject itself into the datastream of unregistered or 
# trapped nodes.  The major failing of arp mode is that 
# it's not 100% in catching all traffic - spurious packets can and will occasionaly get through.
mode=arp
#
# network.rogueinterval
#
# When rogue DHCP server detection is enabled, this parameter defines how often to email administrators.  With its default 
# setting of 10, it will email administrators the details of the previous 10 DHCP offers.
rogueinterval=10
#
# network.dhcpdetector
#
# If enabled, PacketFence will monitor DHCP-specific items such as rogue DHCP services, DHCP-based OS fingerprinting, computername/hostname 
# resolution, and (optionnally) option-82 location-based information.  The monitored DHCP packets are DHCPDISCOVERs and DHCPREQUESTs - both are broadcasts, 
# meaning a span port is not necessary.  This feature is highly recommended if the internal network is DHCP-based.
dhcpdetector=enabled
#
# network.dhcpoption82logger
#
# If enabled PacketFence will monitor DHCP option82 location-based information.
# This feature is only available if the dhcpdetector is activated.
dhcpoption82logger=disabled
#
#
# This section allows you to configure locally proxied content.  We typically use this to proxy tools like Stinger rather 
# than having to continually download the latest version. Ex:
# 
# <i>tools/stinger.exe=http://download.nai.com/products/mcafee-avert/stng260.exe</i>
# 
# The Stinger utility could then be accessed at https://pfhostname/proxies/tools/stinger.exe.
[proxies]
tools/stinger.exe=http://download.nai.com/products/mcafee-avert/stng260.exe

[trapping]
#
# trapping.testing
#
# Disables sending of ARPs - note that this has implications on node detection and timeouts.
testing=enabled
#
# trapping.range
#
# Comma-delimited list of address ranges/CIDR blocks that PacketFence will monitor/detect/trap on.  Gateway, network, and 
# broadcast addresses are ignored.
range=192.168.0.0/24
#
# trapping.registration
#
# If enabled, nodes will be required to register on first network access.  Further registration options are configured in the 
# registration section.
registration=disabled
#
# trapping.immediate
#
# Enable this if you want to see lots of "IP conflict boxes on Windows systems!  On detection of a violation, a spoofed GARP 
# (gratitous ARP) is sent to the offending system.  This causes it to think another system is using its IP address and, under 
# Windows 2000, causes it to disable its IP stack.  When the user manages to get the system back on the wire (ipconfig 
# /release, reboot, etc) he/she will be assigned an address from the isolation scope.
immediate=disabled
#
# trapping.redirtimer
#
# How long to display the progress bar during trap release.  Setting it to a value of 5 or higher is recommended 
# when in arp mode.  Doing so allows the client time to receive and process the redirection ARP sent by PacketFence.
redirtimer=10s
#
# trapping.passthrough
#
# Method by which content is delivered to trapped systems.  When set to "proxy", PacketFence uses Apache's reverse proxy 
# functionality and the mod_proxy_html module to rewrite links.  Note that links external servers will not be properly 
# rewritten.  When set to "iptables", PacketFence creates passthroughs to the content for only those nodes trapped with the
# corresponding violation.  Be aware that an iptables passthrough is based on IP address and clients will be able to get to
# ALL content on the destination site.
passthrough=iptables
#
# trapping.blacklist
#
# Comma-delimited list of MAC addresses that are not allowed to pass through the PacketFence system.
blacklist=
#
# trapping.whitelist
#
# Comma-delimited list of MAC addresses that are immune to isolation. 
# Additionally, in ARP mode no registration/trapping is performed so whitelisted hosts are always allowed to pass.
whitelist=
#
# trapping.redirecturl
#
# Default URL to redirect to on registration/mitigation release.  This is only used if a per-violation redirecturl is not 
# defined.
redirecturl=http://www.packetfence.org
#
# trapping.detection
#
# Enables snort-based worm detection.  If you don't have a span interface available, don't bother enabling it.  If you do, 
# you'll most definately want this on.
detection=disabled

[registration]
#
# registration.range
#
#
range=
#
# registration.skip_mode
#
# If set to "deadline", the deadline option defines the time at which skipping registration is no longer 
# an option for clients.  If set to "window", the window is used to determine the amount of time after 
# first network access that a node may skip registration.
skip_mode=disabled
#
# registration.skip_deadline
#
# If mode is set to "deadline", this is the date at which the "skip registration" option is disabled.  Date 
# string is formatted as the output of the "date" command is.
skip_deadline=Mon Nov 12 12:00:00 EST 2012
#
# registration.skip_window
#
# The length of time that a node may skip registration.  For instance, setting it to 14 days would allow 
# students to skip registration for two weeks, giving them time to get a student ID, password, etc.
skip_window=14d
#
# registration.skip_reminder
#
# Interval that a user is re-prompted to register after skipping.  For example, if skip_window=2w and skip_reminder=1d,
# a user will be allowed to skip for two weeks but will be re-prompted every day.
skip_reminder=1d
#
# registration.auth
#
# Method by which registering nodes will be authenticated.  Templates for LDAP and local are 
# available at <conf_dir>/authentication.  If you wish to use a different authentication mechanism, simply create 
# a file called <conf_dir>/authentication/<authname>.pm, fill it with the necessary data, and set 
# auth=<authname>.  The default value, local, relies on a local access file in <conf_dir>/user.conf.
auth=local
#
# registration.expire_mode
#
# If set to "deadline", the expire_deadline option defines the date at
# which a node reverts to an unregistered state.  If set to "window",
# the window is used to determine the length of time after registration
# that a node remains registered.  If set to "session", it specifies
# that a client should be unregistered as soon as its iplog entry closes
# (or with a bit of latency - check regitration.expire_session).
expire_mode=disabled
#
# registration.expire_deadline
#
# If expire_mode is set to "deadline", this is the date (formatted as returned by the "date" command) at which 
# nodes revert to an unregistered state.  This would typically be the end of a semester.
expire_deadline=Mon Nov 12 12:00:00 EST 2012
#
# registration.expire_window
#
# If expire_mode is set to "window", this is length of time after
# registration that a node reverts to an unregistered state.
expire_window=52w
#
# registration.expire_session
# If expire_mode is set to "session", this is the amount of time after
# a node's iplog entry is closed that it reverts to an unregistered
# state.
# Warning: Does not work in vlan isolation mode!
expire_session=5m
#
# registration.queuesize
#
# Useful for arp deployments on very large networks, this defines the number of nodes that PacketFence 
# will simultaneously trap for registration (trappings due to violation always occur).  If set to 0, this queue is disabled. 
queuesize=0
#
# registration.maxnodes
#
# If defined, the maximum number of nodes that can be registered to a single PID.
maxnodes=0
#
# registration.button_text
#
#
button_text=Register
#
# registration.nbregpages
#
# The number of registration pages to show to the user
nbregpages=1

#
#
# This section allows you to create passthroughs to HTML content or remote addresses/networks.  Here's an example:
# packetfence=http://www.packetfence.org
# The above will allow 80/tcp traffic to the resolved IP address (the LHS value is arbitrary).  Passthroughs can also take the 
# form of:
# test=192.168.100.10/23
# which would allow full IP to all 512 destination addresses.
[passthroughs]

[alerting]
#
# alerting.emailaddr
#
# Email address to which notifications of rogue DHCP servers, violations with an action of "email", or any other 
# PacketFence-related message goes to.
emailaddr=pf@localhost
#
# alerting.smtpserver
#
# Server through which to send messages to the above emailaddr.  The default is localhost - be sure you're running an SMTP 
# host locally if you don't change it!
smtpserver=localhost
#
# alerting.subjectprefix
#
#Subject prefix for email notifications of rogue DHCP servers, violations with an action of "email", or any other
#PacketFence-related message.
subjectprefix=PF Alert:
#
# alerting.log
#
# Log file where "log" actions are sent.
log=violation.log
#
# alerting.wins_server
#
# WINS server to  resolve NetBIOS name of administrative workstation to IP address.
wins_server=192.168.0.100
#
# alerting.admin_netbiosname
#
# NetBIOS name of administrative workstation to send alerts with "winpopup" action assigned.
admin_netbiosname=EXAMPLE

[ports]
#
# ports.redirect
#
# Ports to intercept and redirect for trapped and unregistered systems.  Defaults to 80/tcp (HTTP), 110/tcp (POP3), and 
# 143/tcp (IMAP).  IMAP and POP3 listeners must be enabled via the listeners parameter if the redirection is to be of any use.  
# Redirecting 443/tcp (SSL) will work, although users will get ugly and confusing pop-ups as the commonname will no longer 
# match.  Redirecting 53/udp (DNS) seems to have issues and is also not recommended.
redirect=80/tcp,110/tcp,143/tcp
#
# ports.listeners
#
# Enables "bogus" IMAP and POP servers.  These servers serve only to deliver a message (POP3) or send an alert (IMAP) to 
# inform the user that he/she must register before connectivity is allowed.  Content of the message is found at 
# <conf_dir>/templates/listener.msg
listeners=
#
# ports.admin
#
# Port the administrative interface listens on.
admin=1443

[scan]
#
# scan.ssl
#
# enable ssl communication with the nessus server.   
ssl=enabled
#
# scan.pass
#
# Password to log into nessus server with.
pass=packet
#
# scan.user
#
# Username to log into nessus server with.
user=admin
#
# scan.port
#
# Port nessus server is running on.
port=1241
#
# scan.host
#
# Host the nessus server is running on.  For performance reasons, we recommend running the nessus server remotely.  A 
# passthrough will be automagically created.
host=127.0.0.1
#
# scan.registration
#
# If this option is enabled, pf will scan each host after registration is complete with all nessusids.
registration=disabled
#
# scan.live_tids
#
# If a host fails a scan AND the tid is listed in live_tids the corresponding violation will
# be added. If the tid is not listed here the event will be logged only. This is used to test 
# Nessus plugins before going live. The tid is the Nessus plugin Id.
live_tids=
#
# scan.nessusclient_file
#
# Name of the NessusClient file; the file format is documented at
# http://www.nessus.org/documentation/dot_nessus_file_format.pdf
# This file must be found in conf/nessus/
nessusclient_file=remotescan.nessus
#
# scan.nessusclient_policy
#
# Name of the policy inside the NessusClient file
nessusclient_policy=RemoteScan
#
# scan.duration
#
# Approximate duration of a scan. User being scanned on registration are presented a progress bar 
# for this duration, afterwards the browser refreshes until scan is complete.
duration=60s
#

[database]
#
# database.pass
#
# Password for the mysql database used by PacketFence.
pass=packet
#
# database.db
#
# Name of the mysql database used by PacketFence.
db=pf
#
# database.user
#
# Username of the account with access to the mysql database used by PacketFence.
user=pf
#
# database.port
#
# Port the mysql server is running on.
port=3306
#
# database.host
#
# Server the mysql server is running on.
host=localhost

[expire]
# TODO: validate that this only works in ARP mode or not
#
# expire.node
#
# Time before a node is removed due to inactivity.
# A value of 0d disables expiration.
# example:
# node=90d
node=0d
#
# expire.iplog
#
# Time which you would like to keep logs on IP/MAC information.
# A value of 0d disables expiration.
# example:
# iplog=180d
iplog=0d
#
# expire.traplog
#
# Time which you would like to keep logs on trap information.
# A value of 0d disables expiration.
# example:
# traplog=180d
traplog=0d
#
# expire.locationlog
#
# Time which you would like to keep logs on location information
# Please note that this table should not become too big since it 
# could degrade pfsetvlan performance.
# A value of 0d disables expiration.
# example:
# locationlog=180d
locationlog=0d

[services]
#
# services.snort
#
# Location of the snort binary.  Only necessary to change if you are not running the RPMed version. 
snort=/usr/sbin/snort
#
# services.httpd
#
# Location of the apache binary.  Only necessary to change if you are not running the RPMed version.
httpd=/usr/sbin/httpd
#
# services.dhcpd
#
# Location of the dhcpd binary.  Only necessary to change if you are not running the RPMed version.
dhcpd=/usr/sbin/dhcpd
#
# services.named
#
# Location of the named binary.  Only necessary to change if you are not running the RPMed version.
named=/usr/sbin/named
#
# services.snmptrapd
# Location of the snmptrapd binary.  Only necessary to change if you are not using the RPMed version.
snmptrapd=/usr/sbin/snmptrapd

[dhcp]
#
# dhcp.isolation_lease
#
# Length of lease for isolated clients
isolation_lease=2m
#
# dhcp.unregistered_lease
#
# Length of lease for unregistered clients
unregistered_lease=2m
#
# dhcp.registered_lease 
#
# Length of lease for registered clients
registered_lease=2h

[vlan]
#
# vlan.adjustswitchportvlanreasons
#
# After which calls to pfcmd do we have to re-calculate and re-assign
# the switchport VLAN a node is connected to
adjustswitchportvlanreasons=node_modify,manage_register,manage_deregister,manage_vclose,manage_vopen,violation_modify,violation_add,violation_delete
#
# vlan.adjustswitchportvlanscript
#
# Which script do we have to execute to adjust the switchport VLAN
adjustswitchportvlanscript=flip.pl
#
# vlan.closelocationlogonstop
#
# Should open locationlog entries be closed when pfsetvlan is 
# stopped
closelocationlogonstop=disabled
#
# vlan.dhcpd
#
# Should DHCPd be started ?
#
dhcpd=disabled
#
#
# vlan.named
#
# Should named be started ?
#
named=disabled
#
# vlan.nbtraphandlerthreads
#
# Number of trap handler threads pfsetvlan should start
nbtraphandlerthreads = 20
#
# vlan.nbtrapparserthreads
#
# Number of trap parser threads pfsetvlan should start
nbtrapparserthreads = 5

[servicewatch]
#
# servicewatch.email
#
# should pfcmd service pf watch send an email if services are not running
email=enabled
#
# servicewatch.restart
#
# should pfcmd service pf watch restart PF if services are not running
restart=disabled
